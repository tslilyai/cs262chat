'''
This class implements the interface defined in protocols.py
and wraps the autogenerated protobuf code
'''

from grpc.beta import implementations
import service_pb2 as obj

_TIMEOUT_SECONDS = 30

class Protobuf_Protocol(object):
    # RUN
    def client_run(self, port):
        self.Channel = implementations.insecure_channel('localhost', port)
        self.Stub = service_pb2.beta_create_ChatApp_stub(channel)

    # MESSAGING 
    def send_message(self, src, dest, msg):
        message = obj.CMessage(
            to_id = dest,
            from_id = src,
            msg = msg
        )
        response = self.Stub.rpc_send_message(message, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"
    def get_messages(self, dest):
        #XXX how do we store the client's user state to set username or u_id when we call this function?
        user = obj.User(
            username = self.Username
            password = self.Password
            u_id = self.U_id
        )
        messages = self.Stub.rpc_get_messages(user, _TIMEOUT_SECONDS)
        return [(m.from_id, m.msg) for m in messages]

    # CREATION AND DELETION 
    def create_group(self, groupname):
        group = obj.Group(g_name = groupname)
        response = self.Stub.rpc_create_group(group, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"
    def create_account(self, username):
        user = obj.User(username=username)
        response = self.Stub.rpc_create_account(user, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"
    def remove_account(self):
        user = obj.User(username=username)
        response = self.Stub.rpc_remove_account(user, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"

    # GROUPS 
    def edit_group_name(self, old_name, new_name):
        group = obj.User(g_name=old_name, new_name=new_name)
        response = self.Stub.rpc_edit_group_name(group, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"
    def remove_group_member(self, groupname, member):
        # XXX we'll need to know the member id when we call the function? where will this be stored?
        group = obj.User(g_name=groupname, edit_member_id=member)
        response = self.Stub.rpc_remove_group_member(group, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"
    def add_group_member(self, groupname, member):
        # XXX see comment above
        group = obj.User(g_name=groupname, edit_member_id=member)
        response = self.Stub.rpc_add_group_member(group, _TIMEOUT_SECONDS)
        if response.errno:
            print "Error: ", response.msg
        else: 
            print "success"

    # LISTING 
    def list_groups(self, pattern):
        pattern = obj.Pattern(pattern=pattern) 
        groups = self.Stub.rpc_list_groups(pattern, _TIMEOUT_SECONDS)
        return [g.g_name for g in groups]

    def list_accounts(self, pattern):
        pattern = obj.Pattern(pattern=pattern) 
        users = self.Stub.rpc_list_users(pattern, _TIMEOUT_SECONDS)
        # XXX username might not be unique?
        return [u.username for u in users]

    def list_group_members(self, groupname):
        # XXX what if groups aren't unique?
        group = obj.Group(
            g_name=groupname
        )
        users = self.Stub.rpc_list_group_members(group, _TIMEOUT_SECONDS)
        return [u.username for u in users]
